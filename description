# rv_i detailed descriptions

lui Loads a 20-bit immediate value into the upper 20 bits of the destination register, setting the lower 12 bits to zero. This instruction is commonly used in conjunction with an ADDI instruction to create 32-bit constants. It's particularly useful for loading large constants or addresses into registers, as it allows for efficient encoding of 32-bit values using two instructions. The immediate value is sign-extended and shifted left by 12 bits before being placed in the destination register, which means it can represent multiples of 4096 (2^12).

auipc Adds a 20-bit immediate value (shifted left by 12 bits) to the current PC (Program Counter), storing the full 32-bit result in the destination register. This instruction is particularly useful for PC-relative addressing, especially when used in conjunction with JALR for implementing large PC-relative offsets. It allows for efficient encoding of 32-bit PC-relative addresses, which is crucial for position-independent code. The immediate value is sign-extended and shifted left by 12 bits before being added to the PC, allowing for a range of ±2 GiB around the current PC.

jal Performs an unconditional jump to a PC-relative offset and saves the address of the next instruction (PC+4) in the destination register (usually x1/ra). The offset is encoded in the immediate field, allowing jumps of up to ±1 MiB. This instruction is primarily used for procedure calls, where the return address needs to be saved. The large jump range makes it suitable for most function calls within a program. If the rd field is zero, no return address is saved, allowing JAL to be used for unconditional branches as well.

jalr Jumps to an address computed from a base register (rs1) and a 12-bit immediate offset, saving the address of the next instruction (PC+4) in the destination register (usually x1/ra). This instruction is more flexible than JAL as it allows for computed jumps and can be used for returns, indirect calls, and implementing switch statements. The computed target address is the sum of rs1 and the sign-extended 12-bit immediate, with the least significant bit set to zero. This instruction is crucial for implementing function returns and for calling functions through function pointers.

beq Compares two registers (rs1 and rs2) and conditionally branches if they are equal. If the condition is true, the program counter is updated to PC + immediate, where the immediate is a signed 13-bit offset counting in 2-byte units. This allows for branches within a ±4 KiB range. BEQ is fundamental for implementing conditional statements and loops in high-level languages. It's often used in combination with other branch instructions to create more complex conditions. The zero-overhead loop feature in some RISC-V implementations can use this instruction for loop termination checks.

bne Compares two registers (rs1 and rs2) and conditionally branches if they are not equal. If the condition is true, the program counter is updated to PC + immediate, where the immediate is a signed 13-bit offset counting in 2-byte units. This allows for branches within a ±4 KiB range. BNE is widely used in implementing loops, especially for loop continuation conditions. It's also used in conditional statements and in implementing more complex control flow structures. In combination with BEQ, it forms the basis for most conditional branching in RISC-V assembly.

blt Compares two registers (rs1 and rs2) as signed integers and conditionally branches if rs1 is less than rs2. If the condition is true, the program counter is updated to PC + immediate, where the immediate is a signed 13-bit offset counting in 2-byte units. This instruction is crucial for implementing signed comparisons in loops and conditional statements. It's often used in sorting algorithms, binary searches, and other comparison-based operations. BLT can be combined with BGE to create equality comparisons for signed integers.

bge Compares two registers (rs1 and rs2) as signed integers and conditionally branches if rs1 is greater than or equal to rs2. If the condition is true, the program counter is updated to PC + immediate, where the immediate is a signed 13-bit offset counting in 2-byte units. This instruction complements BLT and is used in similar contexts for signed integer comparisons. It's particularly useful in implementing the upper bound checks in loops and in range-checking operations. BGE can be used to implement less-than-or-equal comparisons by swapping the order of the operands.

bltu Compares two registers (rs1 and rs2) as unsigned integers and conditionally branches if rs1 is less than rs2. If the condition is true, the program counter is updated to PC + immediate, where the immediate is a signed 13-bit offset counting in 2-byte units. BLTU is essential for unsigned comparisons, which are often used with memory addresses, array indices, and other naturally unsigned values. It's particularly useful in bounds checking for arrays and in implementing unsigned arithmetic operations. BLTU can be more efficient than BLT for certain types of comparisons, especially when dealing with memory addresses.

bgeu Compares two registers (rs1 and rs2) as unsigned integers and conditionally branches if rs1 is greater than or equal to rs2. If the condition is true, the program counter is updated to PC + immediate, where the immediate is a signed 13-bit offset counting in 2-byte units. This instruction complements BLTU and is used for similar unsigned comparison operations. It's particularly useful for implementing upper bound checks in loops with unsigned counters, and in range-checking operations involving memory addresses or other unsigned values. BGEU can be used to implement less-than-or-equal comparisons for unsigned integers by swapping the order of the operands.

lb Loads an 8-bit value from memory, sign-extends it to XLEN bits (32 bits in RV32, 64 bits in RV64), and writes it to rd. The effective address is obtained by adding register rs1 to the sign-extended 12-bit offset. This instruction is crucial for accessing individual bytes in memory, such as when working with character data or packed data structures. The sign-extension allows for proper handling of signed 8-bit values in larger integer contexts. LB is often used in string processing, parsing binary data, and accessing byte-addressable devices.

lh Loads a 16-bit value from memory, sign-extends it to XLEN bits, and writes it to rd. The effective address is obtained by adding register rs1 to the sign-extended 12-bit offset. This instruction is used for accessing 16-bit (halfword) data types, such as short integers in C. The sign-extension ensures that signed 16-bit values are correctly interpreted in 32-bit or 64-bit contexts. LH is commonly used in audio processing (for 16-bit samples), in graphics (for certain color depths), and in working with communication protocols that use 16-bit data units.

lw Loads a 32-bit value from memory and writes it to rd. In RV64, the loaded value is sign-extended to 64 bits. The effective address is obtained by adding register rs1 to the sign-extended 12-bit offset. This is the primary instruction for loading 32-bit integers, single-precision floating-point values (when used by the F extension), and memory addresses in RV32. In RV64, it's still widely used for compatibility with 32-bit data and for accessing the lower half of 64-bit values. LW is fundamental in most memory operations, including array access, structure field access, and loading global variables.

lbu Loads an 8-bit value from memory, zero-extends it to XLEN bits, and writes it to rd. The effective address is obtained by adding register rs1 to the sign-extended 12-bit offset. This instruction is used for loading unsigned byte values, ensuring that the upper bits are always zero. It's particularly useful when working with unsigned char types in C, or when processing binary data where the high bits should not be interpreted as a sign. LBU is often used in network protocol implementations, file I/O operations, and when working with binary file formats.

lhu Loads a 16-bit value from memory, zero-extends it to XLEN bits, and writes it to rd. The effective address is obtained by adding register rs1 to the sign-extended 12-bit offset. This instruction is used for loading unsigned halfword (16-bit) values, ensuring that the upper bits are always zero. It's commonly used when working with unsigned short types in C, or in graphics and audio processing where 16-bit unsigned values are common (e.g., certain color or sample formats). LHU is also useful in network protocols and file formats that use 16-bit unsigned fields.

sb Stores the lowest 8 bits from rs2 to memory. The effective address is obtained by adding register rs1 to the sign-extended 12-bit offset. This instruction is essential for writing individual bytes to memory, which is crucial in many low-level operations. It's commonly used in string manipulation, when writing to byte-addressable devices, in network protocol implementations for setting individual flag bits, and in general when working with packed data structures or binary file formats.

sh Stores the lowest 16 bits from rs2 to memory. The effective address is obtained by adding register rs1 to the sign-extended 12-bit offset. This instruction is used for writing 16-bit (halfword) values to memory. It's commonly employed when working with short integer types, in audio processing for storing 16-bit samples, in graphics for certain color depth operations, and in various protocols and file formats that use 16-bit data units. SH is also useful in embedded systems where memory might be arranged in 16-bit words.

sw Stores the lowest 32 bits from rs2 to memory. The effective address is obtained by adding register rs1 to the sign-extended 12-bit offset. This is the primary instruction for storing 32-bit values to memory, including integers, single-precision floating-point values (when used by the F extension), and memory addresses in RV32. In RV64, it's used for storing the lower half of 64-bit values and for compatibility with 32-bit data. SW is fundamental in most memory write operations, including array updates, structure field modifications, and storing computed results or updated global variables.

addi Adds the 12-bit sign-extended immediate to rs1 and writes the result to rd. This is one of the most frequently used instructions in RISC-V, serving multiple purposes. It's used for basic arithmetic with small constants, for adjusting pointers (e.g., accessing structure fields or array elements), and for loading small signed constants into registers. In RV64, it sign-extends the result to 64 bits. ADDI with a zero immediate is used to move values between registers. It's also key in implementing higher-level language constructs like local variable allocation on the stack.

slti Compares rs1 with the sign-extended immediate as signed integers. Sets rd to 1 if rs1 < imm, 0 otherwise. This instruction is used for signed comparisons with constants, which is useful in implementing conditional statements and loops in high-level languages. It's particularly efficient for range checks and for implementing min/max functions with compile-time known bounds. SLTI can be used to create bitmasks based on the sign of a value, which is useful in certain bit manipulation techniques.

sltiu Compares rs1 with the sign-extended immediate as unsigned integers. Sets rd to 1 if rs1 < imm, 0 otherwise. Despite the immediate being sign-extended, the comparison is unsigned. This instruction is crucial for unsigned comparisons with constants, often used in array bounds checking, pointer comparisons, and implementing unsigned arithmetic operations. It's also useful in creating bitmasks for unsigned values and in certain bitwise manipulation techniques. SLTIU with a zero immediate can be used to efficiently check if a register is zero.

xori Performs bitwise XOR between rs1 and the sign-extended 12-bit immediate, writing the result to rd. This instruction is versatile in bitwise operations. It's commonly used for toggling specific bits, implementing simple hash functions, and in certain encryption algorithms. XORI with an immediate of -1 (all ones) performs a bitwise NOT operation, which is useful for inverting bits or implementing logical negation. In boolean algebra implementations, XORI is crucial for exclusive-or operations.

ori Performs bitwise OR between rs1 and the sign-extended 12-bit immediate, writing the result to rd. ORI is essential for setting specific bits in a register while leaving others unchanged. It's often used in flag manipulation, for example, in setting option bits in configuration words. In boolean algebra implementations, ORI is used for logical OR operations with constants. It's also useful in creating bitmasks and in certain bitfield manipulation techniques.

andi Performs bitwise AND between rs1 and the sign-extended 12-bit immediate, writing the result to rd. This instruction is crucial for masking operations, where specific bits need to be isolated or cleared. It's commonly used in bit manipulation, for example, to clear the upper bits of a value or to extract specific bitfields. ANDI is also key in implementing bitwise flags and in certain optimizations where only the lower bits of a value are significant. In boolean algebra, it's used for logical AND operations with constants.

add Adds rs1 and rs2, writing the result to rd. This basic arithmetic operation is fundamental in almost all computational tasks. It's used in address calculations, loop counters, array indexing, and general arithmetic operations in high-level languages. In more complex mathematical operations, ADD forms the basis for multi-word arithmetic and can be used to implement higher-precision calculations. It's also used in pointer arithmetic and in implementing certain algorithms like checksums.

sub Subtracts rs2 from rs1, writing the result to rd. Subtraction is essential in many computational tasks, including address offset calculations, implementing decremental loops, and general arithmetic operations. SUB is often used in comparison operations (by subtracting and then checking the sign of the result) and in implementing more complex mathematical functions. In pointer arithmetic, it's used to calculate the distance between two pointers. SUB is also key in implementing two's complement negation (by subtracting from zero).

sll Shifts rs1 left by the amount specified in the lower 5 (RV32) or 6 (RV64) bits of rs2, writing the result to rd. Left shifts are equivalent to multiplication by powers of 2, making SLL useful for efficient multiplication by constants. It's also crucial in various bit manipulation techniques, such as creating masks or extracting bitfields. In graphics and cryptography, SLL is often used for fast multiplication or for implementing certain algorithms. The instruction can also be used for aligning data to specific byte boundaries.

slt Compares rs1 and rs2 as signed integers. Sets rd to 1 if rs1 < rs2, 0 otherwise. This instruction is fundamental for implementing signed comparisons in more complex conditional structures. It's often used in sorting algorithms, in implementing min/max functions, and in various decision-making processes in programs. SLT can be used to create branching conditions for other instructions, allowing for more complex control flow. It's also useful in implementing certain mathematical functions that depend on the relative ordering of values.

sltu Compares rs1 and rs2 as unsigned integers. Sets rd to 1 if rs1 < rs2, 0 otherwise. SLTU is essential for unsigned comparisons, often used with memory addresses, array indices, and other naturally unsigned values. It's particularly useful in bounds checking for arrays, in implementing unsigned arithmetic operations, and in certain low-level memory management tasks. SLTU can be more efficient than SLT for certain types of comparisons, especially when dealing with memory addresses or when the values are known to be non-negative.

xor Performs bitwise XOR between rs1 and rs2, writing the result to rd. XOR is a versatile operation used in various contexts. In cryptography, it's fundamental to many encryption algorithms and in generating pseudo-random sequences. XOR is used for simple checksums and hash functions, and for toggling bits based on a mask. It's also useful in certain arithmetic operations, like swapping values without a temporary variable or detecting changes between two values. In graphics, XOR can be used for simple drawing operations that can be easily undone.

srl Shifts rs1 right by the amount specified in the lower 5 (RV32) or 6 (RV64) bits of rs2, filling with zeros. Writes the result to rd. Right logical shifts are equivalent to division by powers of 2 for unsigned integers, making SRL useful for efficient division by constants. It's crucial in various bit manipulation techniques, such as extracting the least significant bits of a value. SRL is often used in implementing unsigned integer division algorithms, in certain cryptographic operations, and in graphics processing for color manipulation.

sra Shifts rs1 right by the amount specified in the lower 5 (RV32) or 6 (RV64) bits of rs2, sign-extending (copying the most significant bit). Writes the result to rd. Arithmetic right shifts are equivalent to division by powers of 2 for signed integers, rounding towards negative infinity. SRA is essential in implementing efficient signed division by constants and in certain signal processing operations. It's also used in various algorithms where the

and Performs bitwise AND between rs1 and rs2, writing the result to rd. This instruction is fundamental in bitwise operations and is extensively used in various low-level programming tasks. It's crucial for masking operations, where specific bits need to be isolated or cleared while leaving others unchanged. AND is commonly used in flag manipulation, for extracting specific bitfields from larger words, and in implementing logical operations in boolean algebra. In embedded systems, it's often used for clearing specific bits in control registers. AND is also key in certain optimization techniques where only specific bits of a value are significant, and in implementing bitwise algorithms in cryptography and hash functions.

ebreak Triggers a breakpoint exception, transferring control to a debug environment. This instruction is primarily used for debugging purposes, allowing programmers to set breakpoints in their code for step-by-step execution and inspection. When an EBREAK is encountered during normal execution, it causes the processor to enter debug mode, where the program's state can be examined and modified. This is crucial for identifying and fixing bugs, especially in embedded systems or operating system development where traditional software debuggers might not be available. EBREAK is also sometimes used in implementing system calls or other privilege-level transitions in some RISC-V systems.

ecall Generates an environment call exception, used to make a request to the execution environment (typically an operating system). This instruction is fundamental in implementing system calls, which are the primary mechanism for user-level programs to request services from the operating system. When an ECALL is executed, control is transferred to the operating system or execution environment, which then determines the nature of the request based on values in specific registers. ECALL is crucial in implementing features like file I/O, process management, and other operating system services. In bare-metal environments, it can be used to implement custom exception handling or to switch between different modes of operation.

fence Ensures that all memory accesses and I/O operations issued before the FENCE instruction are completed before any memory accesses or I/O operations after the FENCE are issued. This instruction is crucial in multicore and multiprocessor systems for enforcing memory ordering. FENCE is used to create synchronization points in code, ensuring that all memory operations are visible to other cores or devices in a specific order. It's particularly important in implementing lock-free algorithms, in managing shared memory between cores, and in ensuring proper ordering of memory accesses with respect to memory-mapped I/O operations. FENCE can have different variants to specify which types of operations (reads, writes, I/O) need to be ordered.

fence_tso Provides Total Store Ordering (TSO) memory consistency. It ensures that all stores before the FENCE.TSO instruction are globally visible before any loads after the instruction are performed. This instruction is a lighter-weight version of the general FENCE instruction, specifically designed for architectures that support TSO memory models. FENCE.TSO is particularly useful in implementing synchronization primitives and in porting code from architectures with stronger memory models (like x86) to RISC-V. It provides a balance between the strict ordering of FENCE and the relaxed ordering of normal memory operations, allowing for potential performance optimizations while still ensuring necessary memory consistency in concurrent programs.

or Performs bitwise OR between rs1 and rs2, writing the result to rd. This instruction is essential in bitwise operations and is widely used in various programming tasks. OR is primarily used for setting specific bits in a register while leaving others unchanged. It's commonly employed in flag manipulation, for example, in setting option bits in configuration words or status registers. In boolean algebra implementations, OR is used for logical OR operations. It's also useful in creating bitmasks, in certain bitfield manipulation techniques, and in implementing simple data merging operations. In graphics programming, OR can be used for combining multiple layers or applying certain effects.

sbreak (Superseded by EBREAK) This instruction was used in earlier versions of the RISC-V specification but has been replaced by EBREAK. It was originally intended to trigger a breakpoint exception, similar to the current EBREAK instruction. For compatibility reasons, some implementations may still recognize SBREAK, treating it identically to EBREAK. However, new code should use EBREAK instead. The functionality and use cases are the same as described for EBREAK: primarily for debugging purposes, allowing programmers to set breakpoints in their code for step-by-step execution and inspection in a debug environment.

scall (Superseded by ECALL) This instruction was used in earlier versions of the RISC-V specification but has been replaced by ECALL. It was originally intended to generate a system call exception, similar to the current ECALL instruction. For compatibility reasons, some implementations may still recognize SCALL, treating it identically to ECALL. However, new code should use ECALL instead. The functionality and use cases are the same as described for ECALL: primarily used for making requests to the execution environment (typically an operating system), implementing system calls, and facilitating transitions between privilege levels in RISC-V systems.